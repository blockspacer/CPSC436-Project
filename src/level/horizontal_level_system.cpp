//
// Created by Prayansh Srivastava on 2019-02-15.
//

#include <util/constants.h>
#include <components/transform.h>
#include <components/collidable.h>
#include <components/timer.h>
#include <scene/scene_mode.h>
#include "horizontal_level_system.h"

HorizontalLevelSystem::HorizontalLevelSystem() :
        LevelSystem(),
        mode_(ENDLESS),
        min_difficulty(MIN_DIFFICULTY_EASY),
        max_difficulty(MAX_DIFFICULTY_HARD),
        difficulty_range(DIFFICULTY_RANGE_ENDLESS)
{
    for (int i = 0; i <= MAX_DIFFICULTY_HARD; i++) {
        levels[i] = Level::load_level(i, HORIZONTAL_LEVEL_TYPE);
    }

    levels[END_LEVEL] = Level::load_level(END_LEVEL, HORIZONTAL_LEVEL_TYPE);
}

void HorizontalLevelSystem::init(SceneMode mode, entt::DefaultRegistry &registry) {
    LevelSystem::init(registry);

    mode_ = mode;
    if (mode_ == ENDLESS) {
        rng_.init((unsigned int) rand());
        min_difficulty = MIN_DIFFICULTY_EASY;
        max_difficulty = MAX_DIFFICULTY_HARD;
        difficulty_range = DIFFICULTY_RANGE_ENDLESS;
    } else if (mode_ == STORY_EASY) {
        rng_.init(STORY_SEED);
        min_difficulty = MIN_DIFFICULTY_EASY;
        max_difficulty = MAX_DIFFICULTY_EASY;
        difficulty_range = DIFFICULTY_RANGE_STORY;
    } else if (mode == STORY_HARD) {
        rng_.init(STORY_SEED);
        min_difficulty = MIN_DIFFICULTY_HARD;
        max_difficulty = MAX_DIFFICULTY_HARD;
        difficulty_range = DIFFICULTY_RANGE_STORY;
    }

    last_col_generated_ = last_col_loaded_ = FIRST_COL_X;
    difficulty = min_difficulty;
    difficulty_timer.save_watch(LEVEL_UP_LABEL, LEVEL_UP_INTERVAL);
    load_next_chunk(0);
}

void HorizontalLevelSystem::load_next_chunk() {
    int level = rng_.nextInt(std::max(1, difficulty - difficulty_range), difficulty);
    load_next_chunk(level);
}

void HorizontalLevelSystem::load_next_chunk(int id) {
    Level lvl = levels[id];
    for (int x = 0; x < lvl.width(); x++) {
        std::vector<char> col;
        col.reserve(lvl.height());
        for (int y = 0; y < lvl.height(); y++) {
            col.push_back(lvl.get_tile_at(x, y));
        }
        last_col_loaded_ += CELL_WIDTH;
        chunks_.push(col);
    }
}

// y should range from (-400, 400)

void HorizontalLevelSystem::generate_next_chunk(Blackboard &blackboard,
                                                entt::DefaultRegistry &registry) {
    float off_screen = blackboard.camera.position().x + blackboard.camera.size().x;
    while (last_col_generated_ < off_screen && !chunks_.empty()) { // second condn is safety check
        std::vector<char> col = chunks_.front();
        float y = -400.0f;
        for (int c:col) {
            generateEntity(c, last_col_generated_, y, blackboard, registry, mode_);
            y += CELL_HEIGHT;
        }
        last_col_generated_ += CELL_WIDTH;
        chunks_.pop();
    }
}

void HorizontalLevelSystem::destroy_entities(entt::DefaultRegistry &registry) {
    registry.destroy<Spit>(); // Destroy Spit here since it was not generated by LevelSystem
    LevelSystem::destroy_entities(registry);
}

void HorizontalLevelSystem::update(Blackboard &blackboard, entt::DefaultRegistry &registry) {
    float max_x =
            blackboard.camera.position().x + blackboard.camera.size().x; // some distance off camera
    float min_x =
            blackboard.camera.position().x - blackboard.camera.size().x; // some distance off camera
    while (last_col_loaded_ < max_x) {
        load_next_chunk();
    }

    difficulty_timer.update(blackboard.delta_time);

    if (difficulty < max_difficulty && difficulty_timer.is_done(LEVEL_UP_LABEL)) {
        difficulty++;
        difficulty_timer.reset_watch(LEVEL_UP_LABEL);
    }

    destroy_off_screen(registry, min_x);
    generate_next_chunk(blackboard, registry);
}

void HorizontalLevelSystem::destroy_off_screen(entt::DefaultRegistry &registry, float x) {
    auto platforms = registry.view<Platform, Transform>();
    for (uint32_t entity: platforms) {
        auto &transform = platforms.get<Transform>(entity);
        if (transform.x < x) {
            registry.destroy(entity);
        }
    }

    auto llamas = registry.view<Llama, Transform>();
    for (uint32_t entity: llamas) {
        auto &transform = llamas.get<Transform>(entity);
        if (transform.x < x) {
            registry.destroy(entity);
        }
    }

    auto spits = registry.view<Spit, Transform>();
    for (uint32_t entity: spits) {
        auto &transform = spits.get<Transform>(entity);
        if (transform.x < x) {
            registry.destroy(entity);
        }
    }

    auto breads = registry.view<Bread, Transform>();
    for (uint32_t entity: breads) {
        auto &transform = breads.get<Transform>(entity);
        if (transform.x < x) {
            registry.destroy(entity);
        }
    }

    auto ghosts = registry.view<Ghost, Transform>();
    for (uint32_t entity: ghosts) {
        auto &transform = ghosts.get<Transform>(entity);
        if (transform.x < x) {
            registry.destroy(entity);
        }
    }

    auto obstacles = registry.view<Obstacle, Transform>();
    for (uint32_t entity: obstacles) {
        auto &transform = obstacles.get<Transform>(entity);
        if (transform.x < x) {
            registry.destroy(entity);
        }
    }
}

void HorizontalLevelSystem::generate_end_level() {
    load_next_chunk(END_LEVEL);
}
